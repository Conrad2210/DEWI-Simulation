//
// Generated file, do not edit! Created by nedtool 4.6 from src/LEACH/cl_msg.msg.
//

#ifndef _CL_MSG_M_H_
#define _CL_MSG_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:2</tt> by nedtool.
 * <pre>
 * message ClusterMessage
 * {
 *     int proto;
 *     int srcAddress;
 *     int destAddress;
 * }
 * </pre>
 */
class ClusterMessage : public ::cMessage
{
  protected:
    int proto_var;
    int srcAddress_var;
    int destAddress_var;

  private:
    void copy(const ClusterMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ClusterMessage&);

  public:
    ClusterMessage(const char *name=NULL, int kind=0);
    ClusterMessage(const ClusterMessage& other);
    virtual ~ClusterMessage();
    ClusterMessage& operator=(const ClusterMessage& other);
    virtual ClusterMessage *dup() const {return new ClusterMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getProto() const;
    virtual void setProto(int proto);
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    virtual int getDestAddress() const;
    virtual void setDestAddress(int destAddress);
};

inline void doPacking(cCommBuffer *b, ClusterMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ClusterMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:8</tt> by nedtool.
 * <pre>
 * message Start extends ClusterMessage
 * {
 *     int round;
 * }
 * // Status sent from Node to BS
 * </pre>
 */
class Start : public ::ClusterMessage
{
  protected:
    int round_var;

  private:
    void copy(const Start& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Start&);

  public:
    Start(const char *name=NULL, int kind=0);
    Start(const Start& other);
    virtual ~Start();
    Start& operator=(const Start& other);
    virtual Start *dup() const {return new Start(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getRound() const;
    virtual void setRound(int round);
};

inline void doPacking(cCommBuffer *b, Start& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Start& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:14</tt> by nedtool.
 * <pre>
 * message Status2BSMessage extends ClusterMessage
 * {
 *     int energy;
 *     int status;
 *     int cluster;
 *     int xpos;
 *     int ypos;
 * }
 * 
 * 
 * // BS sends this message to anounce cluster heads to nodes
 * </pre>
 */
class Status2BSMessage : public ::ClusterMessage
{
  protected:
    int energy_var;
    int status_var;
    int cluster_var;
    int xpos_var;
    int ypos_var;

  private:
    void copy(const Status2BSMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Status2BSMessage&);

  public:
    Status2BSMessage(const char *name=NULL, int kind=0);
    Status2BSMessage(const Status2BSMessage& other);
    virtual ~Status2BSMessage();
    Status2BSMessage& operator=(const Status2BSMessage& other);
    virtual Status2BSMessage *dup() const {return new Status2BSMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getEnergy() const;
    virtual void setEnergy(int energy);
    virtual int getStatus() const;
    virtual void setStatus(int status);
    virtual int getCluster() const;
    virtual void setCluster(int cluster);
    virtual int getXpos() const;
    virtual void setXpos(int xpos);
    virtual int getYpos() const;
    virtual void setYpos(int ypos);
};

inline void doPacking(cCommBuffer *b, Status2BSMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Status2BSMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:26</tt> by nedtool.
 * <pre>
 * message ClusterHeadMessage extends ClusterMessage
 * {
 *     int cHead[103];
 * }
 * 
 * 
 * // TDMA message
 * </pre>
 */
class ClusterHeadMessage : public ::ClusterMessage
{
  protected:
    int cHead_var[103];

  private:
    void copy(const ClusterHeadMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ClusterHeadMessage&);

  public:
    ClusterHeadMessage(const char *name=NULL, int kind=0);
    ClusterHeadMessage(const ClusterHeadMessage& other);
    virtual ~ClusterHeadMessage();
    ClusterHeadMessage& operator=(const ClusterHeadMessage& other);
    virtual ClusterHeadMessage *dup() const {return new ClusterHeadMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getCHeadArraySize() const;
    virtual int getCHead(unsigned int k) const;
    virtual void setCHead(unsigned int k, int cHead);
};

inline void doPacking(cCommBuffer *b, ClusterHeadMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ClusterHeadMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:34</tt> by nedtool.
 * <pre>
 * message TDMAMessage extends ClusterMessage
 * {
 *     int frames;
 *     int frameTime;
 *     int tdma[103];      // XXX constant
 * 
 * }
 * 
 * 
 * // Data sent by nodes to cluster heads
 * </pre>
 */
class TDMAMessage : public ::ClusterMessage
{
  protected:
    int frames_var;
    int frameTime_var;
    int tdma_var[103];

  private:
    void copy(const TDMAMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TDMAMessage&);

  public:
    TDMAMessage(const char *name=NULL, int kind=0);
    TDMAMessage(const TDMAMessage& other);
    virtual ~TDMAMessage();
    TDMAMessage& operator=(const TDMAMessage& other);
    virtual TDMAMessage *dup() const {return new TDMAMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getFrames() const;
    virtual void setFrames(int frames);
    virtual int getFrameTime() const;
    virtual void setFrameTime(int frameTime);
    virtual unsigned int getTdmaArraySize() const;
    virtual int getTdma(unsigned int k) const;
    virtual void setTdma(unsigned int k, int tdma);
};

inline void doPacking(cCommBuffer *b, TDMAMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, TDMAMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:45</tt> by nedtool.
 * <pre>
 * message DataToCHMessage extends ClusterMessage
 * {
 *     int data;
 * }
 * 
 * // Data sent by nodes to BS
 * </pre>
 */
class DataToCHMessage : public ::ClusterMessage
{
  protected:
    int data_var;

  private:
    void copy(const DataToCHMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DataToCHMessage&);

  public:
    DataToCHMessage(const char *name=NULL, int kind=0);
    DataToCHMessage(const DataToCHMessage& other);
    virtual ~DataToCHMessage();
    DataToCHMessage& operator=(const DataToCHMessage& other);
    virtual DataToCHMessage *dup() const {return new DataToCHMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getData() const;
    virtual void setData(int data);
};

inline void doPacking(cCommBuffer *b, DataToCHMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DataToCHMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/LEACH/cl_msg.msg:52</tt> by nedtool.
 * <pre>
 * message Data2BSMessage extends ClusterMessage
 * {
 *     int data;
 * }
 * </pre>
 */
class Data2BSMessage : public ::ClusterMessage
{
  protected:
    int data_var;

  private:
    void copy(const Data2BSMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Data2BSMessage&);

  public:
    Data2BSMessage(const char *name=NULL, int kind=0);
    Data2BSMessage(const Data2BSMessage& other);
    virtual ~Data2BSMessage();
    Data2BSMessage& operator=(const Data2BSMessage& other);
    virtual Data2BSMessage *dup() const {return new Data2BSMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getData() const;
    virtual void setData(int data);
};

inline void doPacking(cCommBuffer *b, Data2BSMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Data2BSMessage& obj) {obj.parsimUnpack(b);}


#endif // ifndef _CL_MSG_M_H_

